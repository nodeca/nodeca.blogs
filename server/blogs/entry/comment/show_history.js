// Show edit history
//

'use strict';


const _  = require('lodash');


module.exports = function (N, apiPath) {

  N.validate(apiPath, {
    comment_id: { format: 'mongo', required: true }
  });


  // Check permissions
  //
  N.wire.before(apiPath, async function check_permissions(env) {
    let can_see_history = await env.extras.settings.fetch('can_see_history');

    if (!can_see_history) throw N.io.FORBIDDEN;
  });


  // Fetch comment
  //
  N.wire.before(apiPath, async function fetch_comment(env) {
    env.data.comment = await N.models.blogs.BlogComment
                                 .findById(env.params.comment_id)
                                 .lean(true);

    if (!env.data.comment) throw N.io.NOT_FOUND;
  });


  // Check if user can see this comment
  //
  N.wire.before(apiPath, async function check_access(env) {
    let access_env = { params: {
      comments:  env.data.comment,
      user_info: env.user_info
    } };

    await N.wire.emit('internal:blogs.access.comment', access_env);

    if (!access_env.data.access_read) throw N.io.NOT_FOUND;
  });


  // Using different sanitizer here,
  // because we need to expose editable fields (md) and don't need
  // autogenerated ones (bookmarks, views, html)
  //
  function sanitize_comment(comment) {
    // we can always hide HB status, because it doesn't affect client diffs
    if (comment.st === N.models.blogs.BlogComment.statuses.HB) {
      comment = Object.assign({}, comment);
      comment.st = comment.ste;
      delete comment.ste;
    }

    if (comment.prev_st?.st === N.models.blogs.BlogComment.statuses.HB) {
      comment.prev_st = Object.assign({}, comment.prev_st);
      comment.prev_st.st = comment.prev_st.ste;
      delete comment.prev_st.ste;
    }

    return _.pick(comment, [
      'md',
      'st',
      'ste',
      'del_reason',
      'del_by',
      'prev_st'
    ]);
  }


  // Fetch and return comment edit history
  //
  N.wire.on(apiPath, async function get_comment_history(env) {
    let history = await N.models.blogs.BlogCommentHistory.find()
                            .where('comment').equals(env.data.comment._id)
                            .sort('_id')
                            .lean(true);

    let history_meta = [ {
      user: env.data.comment.user,
      ts:   env.data.comment.ts,
      role: N.models.blogs.BlogCommentHistory.roles.USER
    } ].concat(
      history.map(i => ({ user: i.user, ts: i.ts, role: i.role }))
    );

    let history_comments = history.map(x => x.comment_data)
                            .concat([ env.data.comment ])
                            .map(sanitize_comment);

    env.res.history = _.zip(history_meta, history_comments)
                       .map(([ meta, comment ]) => ({ meta, comment }));

    env.data.users = (env.data.users || []).concat(env.res.history.map(x => x.meta?.user));
  });
};
