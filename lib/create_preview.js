// Generate preview for a long content
//
// This module receives HTML text generated by nodeca parser and returns
// the same HTML text with a cut position marked within it (as <!--cut--> comment).
//
// Algorithm calculates a set of all possible cut positions, then picks optimal cut
// from that set (whichever cut is closest to having 15 lines of text or 1 picture
// above it).
//
// This code uses two metrics: "lines of text" and "pictures" to assess the height of
// any text block. Rules for calculating those metrics are:
//
//  - every bit of raw text shorter than 120 ucs-2 characters counts as
//    "1 line of text"
//
//  - every bit of raw text longer than 120 characters counts as 1 line
//    per each 120 plus 1 for remainder
//
//  - every external picture, video, file attachment, or image attachment
//    regardless of size counts as "1 picture"
//
// A cut is possible after any top level tag, unless there are 3 or less
// lines of text with no pictures below it.
//

'use strict';

const cheerio = require('cheerio');


class Preview {
  constructor(html) {
    this.html = html;
    this.$ = cheerio.load(html, { withEndIndices: true });
  }

  estimate_text_height(text) {
    return Math.ceil(text.length / 120);
  }

  get_metrics(el) {
    let metrics = { lines: 0, images: 0 };

    if (el.type !== 'tag') {
      metrics.lines += this.estimate_text_height(el.data);
      return metrics;
    }

    if (el.name === 'code') {
      this.$(el.children).each((i, child) => {
        if (child.type !== 'tag') {
          metrics.lines += child.data.replace(/\n$/, '').split('\n')
                             .map(t => Math.max(this.estimate_text_height(t), 1))
                             .reduce((a, b) => a + b, 0);
        }
      });

    } else if (el.name === 'div' && this.$(el).hasClass('ez-block')) {
      metrics.images++;

    } else if (el.name === 'img' && this.$(el).hasClass('image')) {
      metrics.images++;

    } else if (el.name === 'a' && this.$(el).hasClass('attach')) {
      metrics.images++;

    } else {
      this.$(el.children).each((i, child) => {
        let { lines, images } = this.get_metrics(child);

        metrics.lines += lines;
        metrics.images += images;
      });
    }

    return metrics;
  }

  get_cuts() {
    let cuts = Array.from(this.$.root().children()).map(el => {
      let metrics = this.get_metrics(el);

      return {
        pos:    el.endIndex + 1,
        lines:  metrics.lines,
        images: metrics.images
      };
    });

    cuts.push({
      pos:    this.html.length,
      lines:  0,
      images: 0
    });

    for (let i = 0; i < cuts.length; i++) {
      cuts[i].lines_before  = cuts[i].lines;
      cuts[i].images_before = cuts[i].images;

      if (i > 0) {
        cuts[i].lines_before  += cuts[i - 1].lines_before;
        cuts[i].images_before += cuts[i - 1].images_before;
      }
    }

    for (let i = cuts.length - 1; i >= 0; i--) {
      cuts[i].lines_after  = 0;
      cuts[i].images_after = 0;

      if (i < cuts.length - 1) {
        cuts[i].lines_after  += cuts[i + 1].lines  + cuts[i + 1].lines_after;
        cuts[i].images_after += cuts[i + 1].images + cuts[i + 1].images_after;
      }
    }

    return cuts;
  }

  to_html() {
    let cuts = this.get_cuts();

    let optimal_cut = cuts.reduce((a, b) => {
      // prevent 3 or less lines of text without pictures under the cut
      if (a.images_after === 0 && a.lines_after <= 3) return b;

      let score1 = Math.abs(a.lines_before + a.images_before * 15 - 15);
      let score2 = Math.abs(b.lines_before + b.images_before * 15 - 15);

      return score1 < score2 ? a : b;
    });

    if (optimal_cut.pos >= this.html.length) return this.html;

    return this.html.slice(0, optimal_cut.pos) + '<!--cut-->' + this.html.slice(optimal_cut.pos);
  }
}


module.exports = function create_preview(html) {
  return new Preview(html).to_html();
};
