// Generate preview for a long content
//
// This module receives HTML text generated by nodeca parser and returns
// the same HTML text with a cut position marked within it (as <!--cut--> comment).
//
// Algorithm calculates a set of all possible cut positions, then picks optimal cut
// from that set (whichever cut is closest to having 15 lines of text or 1 picture
// above it).
//
// This code uses two metrics: "lines of text" and "pictures" to assess the height of
// any text block. Rules for calculating those metrics are:
//
//  - every bit of raw text shorter than 120 ucs-2 characters counts as
//    "1 line of text"
//
//  - every bit of raw text longer than 120 characters counts as 1 line
//    per each 120 plus 1 for remainder
//
//  - every external picture, video, file attachment, or image attachment
//    regardless of size counts as "1 picture"
//
// A cut is possible after any top level tag, unless there are 3 or less
// lines of text with no pictures below it.
//

'use strict';

const cheerio = require('cheerio');

function create_matcher(...conditions) {
  return function (metrics) {
    let pos = 0;

    // process each condition
    for (let c of conditions) {
      let oldpos = pos;
      let name = Object.keys(c)[0];
      let value = c[name];

      for (; value > 0 && pos < metrics.length; pos++) {
        if (metrics[pos].hasOwnProperty('cut')) continue;
        if (!metrics[pos].hasOwnProperty(name)) break;
        if (metrics[pos][name] > value) break;
        value -= metrics[pos][name];
      }

      if (oldpos === pos) break;
    }

    // find cut
    while (pos >= 0) {
      if (pos < metrics.length && metrics[pos].hasOwnProperty('cut')) {
        return metrics[pos].cut;
      }
      pos--;
    }
    return 0;
  };
}

const preview_rules = [];

preview_rules.push(create_matcher({ text: 5 }, { image: 1 }, { text: 5 }));
preview_rules.push(create_matcher({ text: 10 }, { image: 1 }));
preview_rules.push(create_matcher({ image: 1 }, { text: 10 }));
preview_rules.push(create_matcher({ image: 2 }, { text: 3 }));
preview_rules.push(create_matcher({ text: 15 }));

// fallback rule that returns a cut after anything
preview_rules.push(function (metrics) {
  for (let pos = 0; pos < metrics.length; pos++) {
    if (metrics[pos].hasOwnProperty('cut')) return metrics[pos].cut;
  }
  return 0;
});


class Preview {
  constructor(html) {
    this.html = html;
    this.$ = cheerio.load(html, { withEndIndices: true });
  }

  estimate_text_height(text) {
    return Math.ceil(text.trim().length / 120);
  }

  // Transform html tree into flat array, where each element could be:
  //  - { text: N }  - represents N consecutive lines of text in html
  //  - { image: 1 } - represents an image or video
  //  - { cut: M }   - represents a possible cut at input position M
  //
  fetch_metrics(el, metrics) {
    if (el.type !== 'tag') {
      let text = this.estimate_text_height(el.data);
      if (text) metrics.push({ text });
      return metrics;
    }

    if (el.name === 'code') {
      this.$(el).contents().each((i, child) => {
        if (child.type !== 'tag') {
          let text = child.data.replace(/\n$/, '').split('\n')
                       .map(t => Math.max(this.estimate_text_height(t), 1))
                       .reduce((a, b) => a + b, 0);
          metrics.push({ text });
        }
      });

    } else if (el.name === 'div' && this.$(el).hasClass('ez-block')) {
      metrics.push({ image: 1 });

    } else if ((el.name === 'img' || el.name === 'span') && this.$(el).hasClass('image')) {
      metrics.push({ image: 1 });

    } else if ((el.name === 'a' || el.name === 'span') && this.$(el).hasClass('attach')) {
      metrics.push({ image: 1 });

    } else {
      this.$(el).contents().each((i, child) => {
        this.fetch_metrics(child, metrics);
      });
    }

    return metrics;
  }

  to_html() {
    let metrics = [];

    // traverse all top-level elements, put possible cut after each
    this.$.root().contents().each((i, el) => {
      this.fetch_metrics(el, metrics);
      if (metrics.length > 0 && !metrics[metrics.length - 1].cut) {
        metrics.push({ cut: el.endIndex + 1 });
      }
    });

    metrics.push({ cut: this.html.length });

    // forbid cuts before any text
    let lowestpos = 0;
    while (lowestpos < metrics.length) {
      if (!metrics[lowestpos].cut) break;
      lowestpos++;
    }
    metrics = metrics.slice(lowestpos);

    // apply rules to each, find longest applicable
    let cut = preview_rules.map(fn => fn(metrics))
                .reduce((a, b) => (a > b ? a : b));

    if (!(cut > 0 && cut < this.html.length - 1)) return this.html;

    return this.html.slice(0, cut) + '<!--cut-->' + this.html.slice(cut);
  }
}


module.exports = function create_preview(html) {
  if (html.indexOf('<!--cut-->') !== -1) return html;
  return new Preview(html).to_html();
};
