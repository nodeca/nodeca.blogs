// Generate preview for a long content
//
// This module receives HTML text generated by nodeca parser and returns
// the same HTML text with a cut position marked within it (as <!--cut--> comment).
//
// Algorithm calculates a set of all possible cut positions, then picks optimal cut
// from that set (whichever cut is closest to having 15 lines of text or 1 picture
// above it).
//
// This code uses two metrics: "lines of text" and "pictures" to assess the height of
// any text block. Rules for calculating those metrics are:
//
//  - every bit of raw text shorter than 120 ucs-2 characters counts as
//    "1 line of text"
//
//  - every bit of raw text longer than 120 characters counts as 1 line
//    per each 120 plus 1 for remainder
//
//  - every external picture, video, file attachment, or image attachment
//    regardless of size counts as "1 picture"
//
// A cut is possible after any top level tag, unless there are 3 or less
// lines of text with no pictures below it.
//

'use strict';

const cheerio = require('cheerio');

const LINE_LENGTH = 120;

// allowed cut markers:
// <!--cut--> (user cut)
// <!--cut:</em></p>--> (cut inside em and p tags)
const CUT_RE = /<!--cut(?:((?:<[/a-z]+>)*))?-->/i;


function create_matcher(...conditions) {
  return function (metrics) {
    let pos = 0;

    // process each condition
    for (let c of conditions) {
      let oldpos = pos;
      let name = Object.keys(c)[0];
      let value = c[name];

      for (; value > 0 && pos < metrics.length; pos++) {
        if (metrics[pos].hasOwnProperty('cut')) continue;
        if (!metrics[pos].hasOwnProperty(name)) break;
        if (metrics[pos][name] > value) break;
        value -= metrics[pos][name];
      }

      if (oldpos === pos) break;
    }

    // find cut
    let cut_at_top_level = null;
    let cut_inside_paragraph = null;

    for (let i = 0; i < pos; i++) {
      if (metrics[i].hasOwnProperty('cut')) {
        if (metrics[i].tag_stack.length > 0) {
          cut_inside_paragraph = metrics[i];
        } else {
          cut_at_top_level = metrics[i];
        }
      }
    }

    // return top level cut if it's available,
    // fall back to cut inside paragraph (only happens if first paragraph is too big)
    return cut_at_top_level ?? cut_inside_paragraph;
  };
}

const preview_rules = [];

preview_rules.push(create_matcher({ text: 5 }, { image: 1 }, { text: 5 }));
preview_rules.push(create_matcher({ text: 10 }, { image: 1 }));
preview_rules.push(create_matcher({ image: 1 }, { text: 10 }));
preview_rules.push(create_matcher({ image: 2 }, { text: 3 }));
preview_rules.push(create_matcher({ text: 15 }));

// fallback rule that returns a cut after anything
preview_rules.push(function (metrics) {
  for (let pos = 0; pos < metrics.length; pos++) {
    if (metrics[pos].hasOwnProperty('cut')) return metrics[pos];
  }
  return null;
});


class Preview {
  constructor(html) {
    this.html_with_user_cut = html;
    let match = CUT_RE.exec(html);
    this.user_cut_pos = match ? match.index : 0;

    if (match) {
      html = html.slice(0, match.index) + html.slice(match.index + match[0].length).replace(/^\n/, '');

      if (match.index + match[0].length >= this.html_with_user_cut.length - 1) {
        // disregard user cut at the end of the document
        this.user_cut_pos = 0;
      }
    }

    this.html = html;
    this.$ = cheerio.load(html, { withStartIndices: true, withEndIndices: true });
  }

  estimate_text_height(text) {
    return Math.ceil(text.trim().length / LINE_LENGTH);
  }

  // Transform html tree into flat array, where each element could be:
  //  - { text: N }  - represents N consecutive lines of text in html
  //  - { image: 1 } - represents an image or video
  //  - { cut: M }   - represents a possible cut at input position M
  //
  fetch_metrics_from_element(el, metrics, tag_stack) {
    if (el.type !== 'tag') {
      if (!el.data.trim()) return metrics;

      let sentence_end_re = /.+?(?:[\.?!](?=\s)|$)/g;
      let length = 0;
      let m;

      while ((m = sentence_end_re.exec(el.data))) {
        length += m[0].length;
        if (length >= LINE_LENGTH) {
          let lines = Math.floor(length / LINE_LENGTH);
          metrics.push({ text: lines });
          metrics.push({ cut: el.startIndex + m.index + m[0].length, tag_stack });
          length -= lines * LINE_LENGTH;
        }
      }

      if (length > 0) {
        metrics.push({ text: Math.ceil(length / LINE_LENGTH) });
      }

      return metrics;
    }

    if (el.name === 'code') {
      this.$(el).contents().each((i, child) => {
        if (child.type !== 'tag') {
          let text = child.data.replace(/\n$/, '').split('\n')
                       .map(t => Math.max(Math.ceil(t.length / LINE_LENGTH), 1))
                       .reduce((a, b) => a + b, 0);
          metrics.push({ text });
        }
      });

    } else if (el.name === 'div' && this.$(el).hasClass('ez-block')) {
      metrics.push({ image: 1 });

    } else if ((el.name === 'img' || el.name === 'span') && this.$(el).hasClass('image')) {
      metrics.push({ image: 1 });

    } else if ((el.name === 'a' || el.name === 'span') && this.$(el).hasClass('attach')) {
      metrics.push({ image: 1 });

    } else {
      this.$(el).contents().each((i, child) => {
        this.fetch_metrics_from_element(child, metrics, tag_stack.concat([ el.tagName ]));
        // traverse elements, put possible cut after each
        if (metrics.length > 0) {
          if (metrics[metrics.length - 1].cut) metrics.pop();
          metrics.push({ cut: child.endIndex + 1, tag_stack: tag_stack.concat([ el.tagName ]) });
        }
      });
    }

    return metrics;
  }

  fetch_metrics() {
    let metrics = [];

    // traverse all top-level elements, put possible cut after each
    this.$.root().contents().each((i, el) => {
      this.fetch_metrics_from_element(el, metrics, []);
      if (metrics.length > 0) {
        if (metrics[metrics.length - 1].cut) metrics.pop();
        metrics.push({ cut: el.endIndex + 1, tag_stack: [] });
      }
    });

    if (metrics.length && metrics[metrics.length - 1].cut) metrics.pop();
    metrics.push({ cut: this.html.length, tag_stack: [] });

    // forbid cuts before any text
    let lowestpos = 0;
    while (lowestpos < metrics.length) {
      if (!metrics[lowestpos].cut) break;
      lowestpos++;
    }
    metrics = metrics.slice(lowestpos);

    return metrics;
  }

  to_html() {
    let metrics = this.fetch_metrics();

    // apply rules to each, find longest applicable
    let cut_obj = preview_rules.map(fn => fn(metrics))
                    .reduce((a, b) => {
                      if (!a) return b;
                      if (!b) return a;
                      return a.cut > b.cut ? a : b;
                    });

    let result, user_cut_too_large = false, top_too_heavy = false;

    // If we can put cut anywhere, "top_too_heavy" condition will never apply
    /*let images_in_first_paragraph = 0;

    for (let m of metrics) {
      if (m.image) images_in_first_paragraph += m.image;
      if (m.cut) break;
    }

    // this is only a flag for external use, no action is taken here
    if (images_in_first_paragraph > 2) top_too_heavy = true;*/

    let auto_cut_is_within_document = cut_obj && cut_obj.cut < this.html.length - 1;
    let user_cut_is_within_document = this.user_cut_pos > 0;

    if (auto_cut_is_within_document) {
      // we have auto cut and user cut, compare them
      user_cut_too_large = this.user_cut_pos > cut_obj.cut;

      if (user_cut_is_within_document && !user_cut_too_large) {
        // - user cut doesn't exist
        // - user cut is at the start or at the very end
        // - user cut is too large
        result = this.html_with_user_cut;
      } else {
        let { cut, tag_stack } = cut_obj;
        let closing_tags = tag_stack.map(t => `</${t}>`).reverse().join('');
        result = this.html.slice(0, cut) +
                 `<!--cut${closing_tags}-->\n` +
                 this.html.slice(cut);
      }
    } else if (user_cut_is_within_document) {
      // can't place cut automatically, so accept user cut or output the entire html
      result = this.html_with_user_cut;
    } else {
      // document is too small to have any cut in it
      result = this.html;
    }

    return {
      html: result,
      user_cut_too_large,
      top_too_heavy
    };
  }
}


module.exports = function create_preview(html) {
  return new Preview(html).to_html();
};
