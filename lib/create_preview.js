// Generate preview for a long content
//
// This module receives HTML text generated by nodeca parser and returns
// the same HTML text with a cut position marked within it (as <!--cut--> comment).
//
// Algorithm calculates a set of all possible cut positions, then picks optimal cut
// from that set (whichever cut is closest to having 15 lines of text or 1 picture
// above it).
//
// This code uses two metrics: "lines of text" and "pictures" to assess the height of
// any text block. Rules for calculating those metrics are:
//
//  - every bit of raw text shorter than 120 ucs-2 characters counts as
//    "1 line of text"
//
//  - every bit of raw text longer than 120 characters counts as 1 line
//    per each 120 plus 1 for remainder
//
//  - every external picture, video, file attachment, or image attachment
//    regardless of size counts as "1 picture"
//
// A cut is possible after any top level tag, unless there are 3 or less
// lines of text with no pictures below it.
//

'use strict';

const cheerio = require('cheerio');

const CUT_MARKER = '<!--cut-->';


function create_matcher(...conditions) {
  return function (metrics) {
    let pos = 0;

    // process each condition
    for (let c of conditions) {
      let oldpos = pos;
      let name = Object.keys(c)[0];
      let value = c[name];

      for (; value > 0 && pos < metrics.length; pos++) {
        if (metrics[pos].hasOwnProperty('cut')) continue;
        if (!metrics[pos].hasOwnProperty(name)) break;
        if (metrics[pos][name] > value) break;
        value -= metrics[pos][name];
      }

      if (oldpos === pos) break;
    }

    // find cut
    while (pos >= 0) {
      if (pos < metrics.length && metrics[pos].hasOwnProperty('cut')) {
        return metrics[pos].cut;
      }
      pos--;
    }
    return 0;
  };
}

const preview_rules = [];

preview_rules.push(create_matcher({ text: 5 }, { image: 1 }, { text: 5 }));
preview_rules.push(create_matcher({ text: 10 }, { image: 1 }));
preview_rules.push(create_matcher({ image: 1 }, { text: 10 }));
preview_rules.push(create_matcher({ image: 2 }, { text: 3 }));
preview_rules.push(create_matcher({ text: 15 }));

// fallback rule that returns a cut after anything
preview_rules.push(function (metrics) {
  for (let pos = 0; pos < metrics.length; pos++) {
    if (metrics[pos].hasOwnProperty('cut')) return metrics[pos].cut;
  }
  return 0;
});


class Preview {
  constructor(html) {
    this.html_with_user_cut = html;
    this.user_cut_pos = html.indexOf(CUT_MARKER);

    if (this.user_cut_pos !== -1) {
      html = html.slice(0, this.user_cut_pos) + html.slice(this.user_cut_pos + CUT_MARKER.length).replace(/^\n/, '');
    }

    this.html = html;
    this.$ = cheerio.load(html, { withEndIndices: true });
  }

  estimate_text_height(text) {
    return Math.ceil(text.trim().length / 120);
  }

  // Transform html tree into flat array, where each element could be:
  //  - { text: N }  - represents N consecutive lines of text in html
  //  - { image: 1 } - represents an image or video
  //  - { cut: M }   - represents a possible cut at input position M
  //
  fetch_metrics_from_element(el, metrics) {
    if (el.type !== 'tag') {
      let text = this.estimate_text_height(el.data);
      if (text) metrics.push({ text });
      return metrics;
    }

    if (el.name === 'code') {
      this.$(el).contents().each((i, child) => {
        if (child.type !== 'tag') {
          let text = child.data.replace(/\n$/, '').split('\n')
                       .map(t => Math.max(this.estimate_text_height(t), 1))
                       .reduce((a, b) => a + b, 0);
          metrics.push({ text });
        }
      });

    } else if (el.name === 'div' && this.$(el).hasClass('ez-block')) {
      metrics.push({ image: 1 });

    } else if ((el.name === 'img' || el.name === 'span') && this.$(el).hasClass('image')) {
      metrics.push({ image: 1 });

    } else if ((el.name === 'a' || el.name === 'span') && this.$(el).hasClass('attach')) {
      metrics.push({ image: 1 });

    } else {
      this.$(el).contents().each((i, child) => {
        this.fetch_metrics_from_element(child, metrics);
      });
    }

    return metrics;
  }

  fetch_metrics() {
    let metrics = [];

    // traverse all top-level elements, put possible cut after each
    this.$.root().contents().each((i, el) => {
      this.fetch_metrics_from_element(el, metrics);
      if (metrics.length > 0 && !metrics[metrics.length - 1].cut) {
        metrics.push({ cut: el.endIndex + 1 });
      }
    });

    metrics.push({ cut: this.html.length });

    // forbid cuts before any text
    let lowestpos = 0;
    while (lowestpos < metrics.length) {
      if (!metrics[lowestpos].cut) break;
      lowestpos++;
    }
    metrics = metrics.slice(lowestpos);

    return metrics;
  }

  to_html() {
    let metrics = this.fetch_metrics();

    // apply rules to each, find longest applicable
    let cut = preview_rules.map(fn => fn(metrics))
                .reduce((a, b) => (a > b ? a : b));

    let result, user_cut_too_large = false, top_too_heavy = false;

    let images_in_first_paragraph = 0;

    for (let m of metrics) {
      if (m.image) images_in_first_paragraph += m.image;
      if (m.cut) break;
    }

    // this is only a flag for external use, no action is taken here
    if (images_in_first_paragraph > 2) top_too_heavy = true;

    let auto_cut_is_within_document = cut > 0 && cut < this.html.length - 1;
    let user_cut_is_within_document = this.user_cut_pos > 0 &&
                                      this.user_cut_pos + CUT_MARKER.length < this.html_with_user_cut.length - 1;

    if (auto_cut_is_within_document) {
      // we have auto cut and user cut, compare them
      user_cut_too_large = this.user_cut_pos !== -1 && this.user_cut_pos > cut;

      if (user_cut_is_within_document && !user_cut_too_large) {
        // - user cut doesn't exist
        // - user cut is at the start or at the very end
        // - user cut is too large
        result = this.html_with_user_cut;
      } else {
        result = this.html.slice(0, cut) + '\n' + CUT_MARKER + this.html.slice(cut);
      }
    } else if (user_cut_is_within_document) {
      // can't place cut automatically, so accept user cut or output the entire html
      result = this.html_with_user_cut;
    } else {
      // document is too small to have any cut in it
      result = this.html;
    }

    return {
      html: result,
      user_cut_too_large,
      top_too_heavy
    };
  }
}


module.exports = function create_preview(html) {
  return new Preview(html).to_html();
};
